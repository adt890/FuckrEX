// Generated by CoffeeScript 1.8.0
(function() {
  var authenticateFactory, chat, chatController, fuckr, gui, jacasr, nativeMenuBar, pinpoint, profiles, profilesController, updateLocation, updateProfileController;

  authenticateFactory = function($localStorage, $http, $rootScope, $q, $location) {
    var authenticateFunction, onSuccessfulLogin, s4, uuid;
    s4 = function() {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    };
    uuid = function() {
      return ("" + (s4()) + (s4()) + "-" + (s4()) + "-" + (s4()) + "-" + (s4()) + "-" + (s4()) + (s4()) + (s4())).toUpperCase();
    };
    $localStorage.deviceAuthentifier = $localStorage.deviceAuthentifier || uuid();
    $rootScope.profileId = $localStorage.profileId;
    onSuccessfulLogin = function(response) {
      var redirection_link;
      redirection_link = _.findWhere(response.responseHeaders, {
        name: "Location"
      }).value;
      $localStorage.authenticationToken = redirection_link.split('authenticationToken=')[1].split('&')[0];
      $rootScope.profileId = $localStorage.profileId = parseInt(redirection_link.split('profileId=')[1]);
      authenticateFunction().then(function() {
        return $location.path('/profiles');
      }, function() {
        return alert('Your account is probably banned');
      });
      return {
        cancel: true
      };
    };
    chrome.webRequest.onHeadersReceived.addListener(onSuccessfulLogin, {
      urls: ['https://neo-account.grindr.com/sessions?locale=en', 'https://neo-account.grindr.com/users?locale=en']
    }, ['responseHeaders', 'blocking']);
    authenticateFunction = function() {
      return $q(function(resolve, reject) {
        if (!$localStorage.authenticationToken) {
          return reject('no authentication token');
        }
        return $http.post('https://primus.grindr.com/2.0/session', {
          appName: "Grindr",
          appVersion: "2.2.3",
          authenticationToken: $localStorage.authenticationToken,
          deviceIdentifier: $localStorage.deviceAuthentifier,
          platformName: "Android",
          platformVersion: "19",
          profileId: $localStorage.profileId
        }).error(function() {
          $localStorage.authenticationToken = null;
          return reject('wrong token or no connection');
        }).success(function(data, status, headers, config) {
          var sessionId;
          sessionId = headers()['session-id'];
          $http.defaults.headers.common['Session-Id'] = sessionId;
          $http.defaults.headers.common['Cookies'] = "Session-Id=" + sessionId;
          $rootScope.$emit('authenticated', data.xmppToken);
          $rootScope.authenticated = true;
          return resolve();
        });
      });
    };
    $rootScope.logoutAndRestart = function() {
      localStorage.removeItem('ngStorage-authenticationToken');
      return window.location.reload('/');
    };
    chrome.webRequest.onAuthRequired.addListener($rootScope.logoutAndRestart, {
      urls: ["<all_urls>"]
    });
    return authenticateFunction;
  };

  angular.module('authenticate', ['ngStorage']).factory('authenticate', ['$localStorage', '$http', '$rootScope', '$q', '$location', authenticateFactory]);

  jacasr = require('jacasr');

  chat = function($http, $localStorage, $rootScope, $q, profiles) {
    var acknowledgeMessages, addMessage, client, createConversation, s4, sendMessage, uuid;
    s4 = function() {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    };
    uuid = function() {
      return ("" + (s4()) + (s4()) + "-" + (s4()) + "-" + (s4()) + "-" + (s4()) + "-" + (s4()) + (s4()) + (s4())).toUpperCase();
    };
    client = {};
    $localStorage.conversations = $localStorage.conversations || {};
    $localStorage.sentImages = $localStorage.sentImages || [];
    createConversation = function(id) {
      $localStorage.conversations[id] = {
        id: id,
        messages: []
      };
      return profiles.get(id).then(function(profile) {
        return $localStorage.conversations[id].thumbnail = profile.profileImageMediaHash;
      });
    };
    addMessage = function(message) {
      var fromMe, id;
      if (parseInt(message.sourceProfileId) === $localStorage.profileId) {
        fromMe = true;
        id = parseInt(message.targetProfileId);
      } else {
        fromMe = false;
        id = parseInt(message.sourceProfileId);
      }
      if (profiles.isBlocked(id)) {
        return;
      }
      if (message.type === 'block') {
        if ($localStorage.conversations[id]) {
          delete $localStorage.conversations[id];
        }
        if (fromMe) {
          profiles.block(id);
        } else {
          profiles.blockedBy(id);
        }
      } else {
        if (!$localStorage.conversations[id]) {
          createConversation(id);
        }
        $localStorage.conversations[id].lastTimeActive = message.timestamp;
        message = (function() {
          switch (message.type) {
            case 'text':
              return {
                text: message.body
              };
            case 'map':
              return {
                location: angular.fromJson(message.body)
              };
            case 'image':
              return {
                image: angular.fromJson(message.body).imageHash
              };
            default:
              return {
                text: message.type + ' ' + message.body
              };
          }
        })();
        message.fromMe = fromMe;
        $localStorage.conversations[id].messages.push(message);
        if (!fromMe) {
          $localStorage.conversations[id].unread = true;
          document.getElementById('notification').play();
        }
      }
      return $rootScope.$broadcast('new_message');
    };
    acknowledgeMessages = function(messageIds) {
      return $http.post('https://primus.grindr.com/2.0/confirmChatMessagesDelivered', {
        messageIds: messageIds
      });
    };
    $rootScope.$on('authenticated', function(event, token) {
      try {
        client = new jacasr.Client({
          login: $localStorage.profileId,
          password: token,
          domain: 'chat.grindr.com'
        });
      } catch (_error) {
        $rootScope.chatError = true;
        alert("chat error: " + message + ". If you're using public wifi, XMPP protocol is probably blocked.");
      }
      client.on('ready', function() {
        chat.connected = true;
        return $http.get('https://primus.grindr.com/2.0/undeliveredChatMessages').then(function(response) {
          var messageIds;
          messageIds = [];
          _(response.data).sortBy(function(message) {
            return message.timestamp;
          }).forEach(function(message) {
            addMessage(message);
            return messageIds.push(message.messageId);
          });
          if (messageIds.length > 0) {
            return acknowledgeMessages(messageIds);
          }
        });
      });
      return client.on('message', function(_, json) {
        var message;
        message = angular.fromJson(json);
        addMessage(message);
        return acknowledgeMessages([message.messageId]);
      });
    });
    sendMessage = function(type, body, to, save) {
      var message;
      if (save == null) {
        save = true;
      }
      message = {
        targetProfileId: String(to),
        type: type,
        messageId: uuid(),
        timestamp: Date.now(),
        sourceDisplayName: '',
        sourceProfileId: String($localStorage.profileId),
        body: body
      };
      client.push("" + to + "@chat.grindr.com", angular.toJson(message));
      if (save) {
        return addMessage(message);
      }
    };
    return {
      sendText: function(text, to, save) {
        if (save == null) {
          save = true;
        }
        return sendMessage('text', text, to, save);
      },
      getConversation: function(id) {
        return $localStorage.conversations[id];
      },
      lastestConversations: function() {
        return _.sortBy($localStorage.conversations, function(conversation) {
          return -conversation.lastTimeActive;
        });
      },
      sentImages: $localStorage.sentImages,
      sendImage: function(imageHash, to) {
        var messageBody;
        messageBody = angular.toJson({
          imageHash: imageHash
        });
        return sendMessage('image', messageBody, to);
      },
      sendLocation: function(to) {
        var messageBody;
        messageBody = angular.toJson({
          lat: $localStorage.grindrParams.lat,
          lon: $localStorage.grindrParams.lon
        });
        return sendMessage('map', messageBody, to);
      },
      block: function(id) {
        return sendMessage('block', null, id);
      }
    };
  };

  angular.module('chat', ['ngStorage', 'profiles']).factory('chat', ['$http', '$localStorage', '$rootScope', '$q', 'profiles', chat]);

  pinpoint = function($q, $localStorage, profiles) {
    var randomizedLocation, trilaterate;
    trilaterate = function(beacons) {
      var P1, P2, P3, d, deg, earthR, ex, ey, ez, i, j, rad, triPt, x, y, z, _ref;
      earthR = 6371;
      rad = function(deg) {
        return deg * math.pi / 180;
      };
      deg = function(rad) {
        return rad * 180 / math.pi;
      };
      _ref = beacons.map(function(beacon) {
        return [earthR * math.cos(rad(beacon.lat)) * math.cos(rad(beacon.lon)), earthR * math.cos(rad(beacon.lat)) * math.sin(rad(beacon.lon)), earthR * math.sin(rad(beacon.lat))];
      }), P1 = _ref[0], P2 = _ref[1], P3 = _ref[2];
      ex = math.divide(math.subtract(P2, P1), math.norm(math.subtract(P2, P1)));
      i = math.dot(ex, math.subtract(P3, P1));
      ey = math.divide(math.subtract(math.subtract(P3, P1), math.multiply(i, ex)), math.norm(math.subtract(math.subtract(P3, P1), math.multiply(i, ex))));
      ez = math.cross(ex, ey);
      d = math.norm(math.subtract(P2, P1));
      j = math.dot(ey, math.subtract(P3, P1));
      x = (math.pow(beacons[0].dist, 2) - math.pow(beacons[1].dist, 2) + math.pow(d, 2)) / (2 * d);
      y = (math.pow(beacons[0].dist, 2) - math.pow(beacons[2].dist, 2) + math.pow(i, 2) + math.pow(j, 2)) / (2 * j) - (i / j * x);
      z = math.sqrt(math.abs(math.pow(beacons[0].dist, 2) - math.pow(x, 2) - math.pow(y, 2)));
      triPt = math.add(math.add(math.add(P1, math.multiply(x, ex)), math.multiply(y, ey)), math.multiply(z, ez));
      return {
        lat: deg(math.asin(math.divide(triPt[2], earthR))),
        lon: deg(math.atan2(triPt[1], triPt[0]))
      };
    };
    randomizedLocation = function() {
      return {
        lat: $localStorage.grindrParams.lat + ((Math.random() - 0.5) / 100),
        lon: $localStorage.grindrParams.lon + ((Math.random() - 0.5) / 100)
      };
    };
    return function(id) {
      var beacons, deferred, promises;
      deferred = $q.defer();
      beacons = [randomizedLocation(), randomizedLocation(), randomizedLocation()];
      promises = beacons.map(function(location) {
        var params;
        params = _.clone($localStorage.grindrParams);
        params.lat = location.lat;
        params.lon = location.lon;
        return profiles.nearby(params);
      });
      $q.all(promises).then(function(results) {
        var i, profile, _i;
        for (i = _i = 0; _i <= 2; i = ++_i) {
          profile = _.findWhere(results[i], {
            profileId: id
          });
          if (!profile) {
            return deferred.reject();
          }
          beacons[i].dist = profile.distance;
        }
        return deferred.resolve(trilaterate(beacons));
      });
      return deferred.promise;
    };
  };

  angular.module('pinpoint', ['profiles']).factory('pinpoint', ['$q', '$localStorage', 'profiles', pinpoint]);

  profiles = function($http, $q, $rootScope) {
    var blocked, profileCache;
    profileCache = {};
    blocked = [];
    $rootScope.$on('authenticated', function() {
      return $http.get('https://primus.grindr.com/2.0/blocks').then(function(response) {
        return blocked = _.intersection(response.data.blockedBy, response.data.blocking);
      });
    });
    return {
      nearby: function(params) {
        var deferred;
        deferred = $q.defer();
        $http.post('https://primus.grindr.com/2.0/nearbyProfiles', params).then(function(response) {
          var profile, _i, _len;
          profiles = _.reject(response.data.profiles, function(profile) {
            return _.contains(blocked, profile.profileId);
          });
          for (_i = 0, _len = profiles.length; _i < _len; _i++) {
            profile = profiles[_i];
            if (!profileCache[profile.profileId]) {
              profileCache[profile.profileId] = profile;
            }
          }
          return deferred.resolve(profiles);
        });
        return deferred.promise;
      },
      get: function(id) {
        var deferred;
        if (profileCache[id]) {
          return $q.when(profileCache[id]);
        } else {
          deferred = $q.defer();
          $http.post('https://primus.grindr.com/2.0/getProfiles', {
            targetProfileIds: [id]
          }).then(function(response) {
            return deferred.resolve(response.data[0]);
          });
          return deferred.promise;
        }
      },
      blockedBy: function(id) {
        blocked.push(id);
        return delete profileCache[id];
      },
      block: function(id) {
        this.blockedBy(id);
        return $http.post('https://primus.grindr.com/2.0/blockProfiles', {
          targetProfileIds: [id]
        });
      },
      isBlocked: function(id) {
        return _.contains(blocked, id);
      }
    };
  };

  angular.module('profiles', []).factory('profiles', ['$http', '$q', '$rootScope', profiles]);

  updateLocation = function($rootScope, $http, $localStorage, $interval) {
    return $rootScope.$on('authenticated', function() {
      return $interval(function() {
        return $http.put('https://primus.grindr.com/2.0/location', {
          lat: $localStorage.grindrParams.lat,
          lon: $localStorage.grindrParams.lon,
          profileId: $localStorage.profileId
        });
      }, 90000);
    });
  };

  angular.module('updateLocation', []).service('updateLocation', ['$rootScope', '$http', '$localStorage', '$interval', updateLocation]);

  angular.module('uploadImage', []).factory('uploadImage', [
    '$http', '$q', function($http, $q) {
      var uploadImage;
      uploadImage = function(file, urlFunction) {
        var deferred, img;
        deferred = $q.defer();
        img = new Image;
        img.src = URL.createObjectURL(file);
        img.onload = function() {
          return $http({
            method: "POST",
            url: urlFunction(img.width, img.height),
            data: file,
            headers: {
              'Content-Type': file.type
            }
          }).then(function(response) {
            return deferred.resolve(response.data.mediaHash);
          });
        };
        return deferred.promise;
      };
      return {
        uploadChatImage: function(file) {
          return uploadImage(file, function(width, height) {
            return "https://neo-upload.grindr.com/2.0/chatImage/" + height + ",0," + width + ",0";
          });
        },
        uploadProfileImage: function(file) {
          return uploadImage(file, function(width, height) {
            var squareSize;
            squareSize = _.min([width, height]);
            return "https://neo-upload.grindr.com/2.0/profileImage/" + height + ",0," + width + ",0/" + squareSize + ",0," + squareSize + ",0";
          });
        }
      };
    }
  ]);

  chatController = function($scope, $routeParams, chat, uploadImage) {
    $scope.lastestConversations = chat.lastestConversations();
    $scope.open = function(id) {
      $scope.conversationId = id;
      $scope.conversation = chat.getConversation(id);
      if ($scope.conversation) {
        $scope.conversation.unread = false;
      }
      return $scope.sentImages = null;
    };
    if ($routeParams.id) {
      $scope.open($routeParams.id);
    }
    $scope.$on('new_message', function() {
      $scope.conversation = chat.getConversation($scope.conversationId);
      return $scope.lastestConversations = chat.lastestConversations();
    });
    $scope.sendText = function() {
      chat.sendText($scope.message, $scope.conversationId);
      return $scope.message = '';
    };
    $scope.showSentImages = function() {
      return $scope.sentImages = chat.sentImages;
    };
    $scope.$watch('imageFile', function() {
      if ($scope.imageFile) {
        $scope.uploading = true;
        return uploadImage.uploadChatImage($scope.imageFile).then(function(imageHash) {
          $scope.uploading = false;
          if (imageHash) {
            return chat.sentImages.push(imageHash);
          }
        });
      }
    });
    $scope.sendImage = function(imageHash) {
      return chat.sendImage(imageHash, $scope.conversationId);
    };
    $scope.sendLocation = function() {
      return chat.sendLocation($scope.conversationId);
    };
    return $scope.block = function() {
      if (confirm('Sure you want to block him?')) {
        chat.block($scope.conversationId);
        $scope.conversationId = null;
        return $scope.lastestConversations = chat.lastestConversations();
      }
    };
  };

  angular.module('chatController', ['ngRoute', 'file-model', 'chat', 'uploadImage']).controller('chatController', ['$scope', '$routeParams', 'chat', 'uploadImage', chatController]);

  profilesController = function($scope, $interval, $localStorage, $routeParams, $window, profiles, pinpoint) {
    var autocomplete;
    $scope.$storage = $localStorage.$default({
      location: 'San Francisco, CA',
      grindrParams: {
        lat: 37.7833,
        lon: -122.4167,
        filter: {
          ageMinimum: null,
          ageMaximum: null,
          photoOnly: true,
          onlineOnly: false,
          page: 1,
          quantity: 300
        }
      }
    });
    $scope.refresh = function() {
      return profiles.nearby($scope.$storage.grindrParams).then(function(profiles) {
        return $scope.nearbyProfiles = profiles;
      });
    };
    $scope.refresh();
    $interval($scope.refresh, 60000);
    autocomplete = new google.maps.places.Autocomplete(document.getElementById('location'));
    google.maps.event.addListener(autocomplete, 'place_changed', function() {
      var place;
      place = autocomplete.getPlace();
      $scope.$storage.location = place.formatted_address;
      if (place.geometry) {
        $scope.$storage.grindrParams.lat = place.geometry.location.lat();
        $scope.$storage.grindrParams.lon = place.geometry.location.lng();
        return $scope.refresh();
      }
    });
    $scope.open = function(id) {
      $scope.isNearbyProfile = parseInt($routeParams.id) !== id;
      return profiles.get(id).then(function(profile) {
        return $scope.profile = profile;
      });
    };
    if ($routeParams.id) {
      $scope.open(parseInt($routeParams.id));
    }
    return $scope.pinpoint = function(id) {
      $scope.pinpointing = true;
      return pinpoint(id).then(function(location) {
        var url;
        $scope.pinpointing = false;
        url = "https://maps.google.com/?q=loc:" + location.lat + "," + location.lon;
        return $window.open(url, '_blank');
      }, function() {
        return $scope.pinpointing = false;
      });
    };
  };

  angular.module('profilesController', ['ngtimeago', 'ngRoute', 'ngStorage', 'profiles', 'pinpoint']).controller('profilesController', ['$scope', '$interval', '$localStorage', '$routeParams', '$window', 'profiles', 'pinpoint', profilesController]);

  updateProfileController = function($scope, $http, $rootScope, profiles, uploadImage) {
    $scope.profile = {};
    profiles.get($rootScope.profileId).then(function(profile) {
      return $scope.profile = profile;
    });
    $scope.updateAttribute = function(attribute) {
      var data;
      data = {};
      data[attribute] = $scope.profile[attribute];
      if (data !== {}) {
        return $http.put('https://primus.grindr.com/2.0/profile', data);
      }
    };
    return $scope.$watch('imageFile', function() {
      if ($scope.imageFile) {
        $scope.uploading = true;
        return uploadImage.uploadProfileImage($scope.imageFile).then(function() {
          return alert("Image up for review by some Grindr™ monkey");
        }, function() {
          return alert("Image upload failed");
        })["finally"](function() {
          return $scope.uploading = false;
        });
      }
    });
  };

  angular.module('updateProfileController', ['file-model', 'uploadImage']).controller('updateProfileController', ['$scope', '$http', '$rootScope', 'profiles', 'uploadImage', updateProfileController]);

  if (typeof process !== 'undefined' && process.platform === 'darwin') {
    gui = require('nw.gui');
    nativeMenuBar = new gui.Menu({
      type: "menubar"
    });
    nativeMenuBar.createMacBuiltin("Fuckr");
    gui.Window.get().menu = nativeMenuBar;
  }

  fuckr = angular.module('fuckr', ['ngRoute', 'profiles', 'profilesController', 'authenticate', 'chat', 'chatController', 'updateLocation', 'updateProfileController']);

  fuckr.config([
    '$httpProvider', '$routeProvider', function($httpProvider, $routeProvider) {
      var name, route, _i, _len, _ref, _results;
      $httpProvider.defaults.headers.common.Accept = '*/*';
      $routeProvider.when('/login', {
        templateUrl: 'views/login.html'
      });
      _ref = ['/profiles/:id?', '/chat/:id?', '/updateProfile'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        route = _ref[_i];
        name = route.split('/')[1];
        _results.push($routeProvider.when(route, {
          templateUrl: "views/" + name + ".html",
          controller: "" + name + "Controller"
        }));
      }
      return _results;
    }
  ]);

  fuckr.run([
    '$location', '$injector', 'authenticate', function($location, $injector, authenticate) {
      var factory, _i, _len, _ref;
      _ref = ['profiles', 'chat', 'updateLocation'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        factory = _ref[_i];
        $injector.get(factory);
      }
      return authenticate().then(function() {
        return $location.path('/profiles/');
      }, function() {
        return $location.path('/login');
      });
    }
  ]);

}).call(this);
